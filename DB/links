VkImportPlugin, CommonImportUiPlugin, 	AnalyticsRefreshTokenUiPlugin, AdWordsRefreshTokenUiPlugin
DirectAnalitics Adwords

CREATE TABLE [client].[CallTouchDataRaw](
	[Id] [int] NOT NULL,
	[Date] [datetime] NOT NULL,
	[AtomId] [int] NULL,
	[Version] [int] NULL,
	[BindingRuleId] [int] NULL,
	[CallerNumber] [nvarchar](200) NOT NULL,
	[Source] [nvarchar](max) NULL,
	[Medium] [nvarchar](max) NULL,
	[UtmSource] [nvarchar](max) NULL,
	[UtmMedium] [nvarchar](max) NULL,
	[UtmCampaign] [nvarchar](max) NULL,
	[UtmTerm] [nvarchar](max) NULL,
	[UtmContent] [nvarchar](max) NULL,
	[From] [nvarchar](max) NULL,
	[To] [nvarchar](max) NULL,
	[KeyWords] [nvarchar](max) NULL,
	[City] [nvarchar](max) NULL,
	[Country] [nvarchar](max) NULL,
	[Duration] [nvarchar](20) NULL,
	[Waiting] [nvarchar](20) NULL,
	[ResponderNumber] [nvarchar](200) NULL,
	[CallsFromSource] [int] NULL,
	[Status] [nvarchar](100) NULL,
	[ClientId] [nvarchar](max) NULL,
	[IsFirsCall] [nvarchar](100) NULL,
	[Page] [nvarchar](max) NULL,
	[Cid] [nvarchar](200) NULL,
	[YandexMetricaId] [nvarchar](max) NULL,
	[Rating] [nvarchar](100) NULL,
	[GaFound] [bit] NULL,
	[GaSource] [nvarchar](max) NULL,
	[GaMedium] [nvarchar](max) NULL,
	[GaCampaign] [nvarchar](max) NULL,
	[GaHostName] [nvarchar](1024) NULL,
PRIMARY KEY CLUSTERED 
(
	[Id] ASC
)WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO



CREATE TABLE [client].[CallTouchComments](
	[Id] [int] NOT NULL,
	[CallId] [int] NOT NULL,
	[Comment] [nvarchar](max) NOT NULL,
	[PartyId] [int] NULL,
	[PartyName] [nvarchar](200) NULL,
PRIMARY KEY CLUSTERED 
(
	[Id] ASC
)WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO

CREATE TABLE [client].[Applications](
	[Id] [bigint] IDENTITY(1,1) NOT NULL,
	[AtomId] [int] NULL,
	[Version] [int] NULL,
	[AccountId] [nvarchar](50) NOT NULL,
	[CreatedOn] [datetime] NOT NULL,
	[ClientId] [nvarchar](max) NULL,
	[DataSource] [nvarchar](max) NULL,
	[Source] [nvarchar](max) NULL,
	[Medium] [nvarchar](max) NULL,
	[Campaign] [nvarchar](max) NULL,
	[Content] [nvarchar](max) NULL,
	[Term] [nvarchar](max) NULL,
	[FullUrl] [nvarchar](max) NULL,
	[DateStatus] [datetime] NULL,
	[Label] [nvarchar](300) NULL,
	[GaFound] [bit] NULL,
	[GaSource] [nvarchar](max) NULL,
	[GaMedium] [nvarchar](max) NULL,
	[GaCampaign] [nvarchar](max) NULL,
	[GaPapId] [nvarchar](max) NULL,
	[BindingRuleId] [int] NULL,
	[GaHostName] [nvarchar](1024) NULL,
	[PhoneHash] [nvarchar](100) NOT NULL,
 CONSTRAINT [PK_Applications] PRIMARY KEY CLUSTERED 
(
	[Id] ASC
)WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO

CREATE TABLE [client].[CallTouchTags](
	[Id] [int] IDENTITY(1,1) NOT NULL,
	[CallId] [int] NOT NULL,
	[Category] [nvarchar](200) NULL,
	[Type] [nvarchar](200) NULL,
PRIMARY KEY CLUSTERED 
(
	[Id] ASC
)WITH (STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO


public static class CoreHelper
    {
        private static EleanorCoreEntities _entities = new EleanorCoreEntities();

        static CoreHelper()
        {
            ((IObjectContextAdapter) _entities).ObjectContext.CommandTimeout = Int32.MaxValue;
        }

        public static void UniversalBulkInsert(String xmlString, Boolean cleanup, DateTime? startDate, DateTime? endDate, Boolean mapOnly, String tableAndSchema, String cleanupFilterColumn)
        {
            _entities.UniversalBulkInsert(xmlString, cleanup, startDate, endDate, mapOnly, tableAndSchema, cleanupFilterColumn);
        }
        public static void InsertDailyData<T>(List<T> dailyData, bool mapOnly, bool cleanup, DateTime? date, string tableAndSchema, string cleanupFilterColumn)
            where T : class
        {
            var serializer = new EntityToXml<T>(tableAndSchema);
            var xmlString = serializer.GetXmlString(dailyData, mapOnly);
            _entities.UniversalBulkInsert(xmlString, cleanup, date, date, mapOnly, tableAndSchema, cleanupFilterColumn);
        }
        public static void InsertData<T>(List<T> data, bool mapOnly, bool cleanup, DateTime? startDate, DateTime? endDate, string tableAndSchema, string cleanupFilterColumn)
            where T : class
        {
            var serializer = new EntityToXml<T>(tableAndSchema);
            var xmlString = serializer.GetXmlString(data, mapOnly);
            _entities.UniversalBulkInsert(xmlString, cleanup, startDate, endDate, mapOnly, tableAndSchema, cleanupFilterColumn);
        }
    }



using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using ITA.Eleanor.Db;

namespace ITA.Eleanor.Infrastructure
{
    public enum FieldsRule
    {
        All              // Все открытые свойства класса
        , BySql          // Только совпадающие по имени с полями таблицы на SQL 
        , ByAnnotation   // Все открытые свойства класса у которых нет атрибута [NotMapped]
    };

    public class EntityToXml<T> where T : class
    {
        private readonly string _tableName;
        private DataTable _tableSchema;
        private List<string> _neededFields;
        public int NumbersOfInvalid;
        public EntityToXml(string tableName)
        {
            _tableName = tableName ?? throw new Exception("tableName не может быть пустым!");
        }
        /// <summary>
        /// Сформирует XML из списка экземпляров класса T
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list">Список записей</param>
        /// <param name="rule">Вид формирования полей</param>
        /// <param name="validate">Валидировать данные</param>
        /// <returns></returns>
        public string GetXmlString(List<T> list, FieldsRule rule, bool validate)
        {
            var validatedList = new List<T>();
            _neededFields = _neededFields ?? GetFieldNames(typeof(T), rule);
            NumbersOfInvalid = 0;
            if (validate)
            {
                foreach (var item in list)
                    if (ItemIsValid(item, rule))
                        validatedList.Add(item);
                    else
                        NumbersOfInvalid++;
            }
            else
                validatedList = list;

            // Список полей которые попадут в XML
            var properties = TypeDescriptor
                .GetProperties(typeof(T)).Cast<PropertyDescriptor>()
                .Where(w => _neededFields.Contains(w.Name))
                .ToList();

            XElement content = new XElement("ROOT",
                    validatedList.Select(row => new XElement("ITEM",
                        properties.Where(w => !string.IsNullOrEmpty(GetValue(w, row))).Select(prop => new XAttribute(prop.Name, GetValue(prop, row))))));

            return new XDocument(content).ToString();
        }

        public string GetXmlString(List<T> list, bool mapOnly)
        {
            _neededFields = GetFieldNames(typeof(T), FieldsRule.BySql);
            if (mapOnly)
            {
                string[] fields = { "Id", "AtomId", "Version", "BindingRuleId" };
                _neededFields = _neededFields.Where(w => fields.Contains(w)).ToList();
                if (_neededFields.Count==0)
                    throw new Exception($"Таблица {_tableName} не содержит полей для перепривязки!");
                return GetXmlString(list, FieldsRule.BySql, false);
            }
            return GetXmlString(list, FieldsRule.BySql, false);
        }
        private string GetValue(PropertyDescriptor prop, T row)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0}", prop.GetValue(row));
        }
        private List<string> GetFieldNames(Type obj, FieldsRule rule)
        {
            var prop = obj.GetProperties();
            switch (rule)
            {
                case FieldsRule.All:
                    return prop.Select(s => s.Name).ToList();
                case FieldsRule.BySql:
                    _tableSchema = GetSqlTableSchema();
                    return _tableSchema.Columns.Cast<DataColumn>().Select(s => s.ColumnName).ToList();
                case FieldsRule.ByAnnotation:
                    return prop.Where(w => !w.GetCustomAttributes(true).Any(c => c.GetType() == typeof(NotMappedAttribute))).Select(s => s.Name).ToList();
                default:
                    throw new ArgumentOutOfRangeException(nameof(rule), rule, null);
            }
        }
        private DataTable GetSqlTableSchema()
        {
            var result = new DataTable();
            using (var connection = new SqlConnection(EleanorConnectionContext.Current.ConnectionString))
            {
                connection.Open();
                var query = $"SELECT TOP 1 * FROM {_tableName}";
                using (var command = new SqlCommand(query, connection))
                {
                    var reader = command.ExecuteReader(CommandBehavior.SchemaOnly);
                    result.Load(reader);
                }
                return result;
            }
        }
        private static List<ValidationResult> Validate(T entity)
        {
            var results = new List<ValidationResult>();
            var vc = new ValidationContext(entity, null, null);
            Validator.TryValidateObject(entity, vc, results, true);
            return results;
        }
        private bool ItemIsValid(T item, FieldsRule rule)
        {
            if (rule == FieldsRule.ByAnnotation)
            {
                var results = Validate(item);
                return results.Count <= 0;
            }
            if (rule == FieldsRule.BySql)
            {
                var table = _tableSchema.Clone();
                // Список полей которые попадут в XML
                var properties = TypeDescriptor.GetProperties(typeof(T));
                var row = table.NewRow();
                foreach (PropertyDescriptor prop in properties)
                {
                    if (prop.GetValue(item) == null) continue;
                    if (_tableSchema.Columns.Cast<DataColumn>().Any(c => c.ColumnName == prop.Name))
                        row[prop.Name] = prop.GetValue(item) ?? DBNull.Value;
                }
                try
                {
                    table.Rows.Add(row);
                    return true;
                }
                catch 
                {
                    return false;
                }

            }
            return true;
        }
    }
}




