        public async Task MapAtomsAsync(string storedProcName)
        {
            InProgress = true;
            _storedProcName = storedProcName;
            var sw = new System.Diagnostics.Stopwatch();
            sw.Start();
            _logger?.Log(LogLevel.Message, $"Привязка {storedProcName} c {_fromDate.ToShortDateString()} по {_toDate.ToShortDateString()} потоков {_threads} шаг {_stepDays}");
            DateTime startDate = _fromDate;
            DateTime endDate = _fromDate;
            
            // Соберем все задачи в список
            List<Action> mappers = new List<Action>();
            int num=1;
            while (endDate < _toDate)
            {
                CancellationContext.ThrowIfCancellationRequested();
                endDate = startDate.AddDays(_stepDays) >= _toDate ? _toDate : startDate.AddDays(_stepDays);
                var tuple = Tuple.Create(startDate, endDate, num);
                // startDate, endDate, num использовать нельзя, т.к. они будут одинаковыми для всех Action
                mappers.Add( () => { Map(tuple.Item1, tuple.Item2, tuple.Item3); } );
                if (endDate >= _toDate) break;
                startDate = startDate.AddDays(_stepDays + 1);
                num++;
            }
            
            // Обработка задач в n потоков (loops)
            int loops = mappers.Count < _threads ? mappers.Count : _threads;
            List<Task> mappingTasks = new List<Task>();
            
            // Пустим n первых потоков
            for (int i = 0; i < loops; i++)
                mappingTasks.Add(Task.Run(mappers[i]));
            int lastIndex = loops+1;

            // Ждем пока все потоки не будут обработаны
            while (mappingTasks.Count>0)
            {
                var completed = await Task.WhenAny(mappingTasks);
                mappingTasks.Remove(completed);
                if (lastIndex < mappers.Count)
                {
                    mappingTasks.Add(Task.Run(mappers[lastIndex]));
                    lastIndex++;
                }
            }

            InProgress = false;
            sw.Stop();
            _logger?.Log(LogLevel.Message, $"Привязка к атомам для {storedProcName} завершена. Время {sw.Elapsed.ToString(@"m\:ss\.ff")}");
        }

        public void MapAtoms(string storedProcName)
        {
            MapAtomsAsync(storedProcName).Wait();
        }

        private async Task Map(DateTime fromDate, DateTime toDate, int thread)
        {
            var sw = new System.Diagnostics.Stopwatch();
            sw.Start();

            var startDateParameter = new ObjectParameter("startDate", fromDate);
            var endDateParameter = new ObjectParameter("endDate", toDate);
            using (var ctx = new EleanorCoreEntities())
            {
                ((IObjectContextAdapter)ctx).ObjectContext.CommandTimeout = Int32.MaxValue;
                ((IObjectContextAdapter)ctx).ObjectContext.ExecuteFunction(_storedProcName, startDateParameter, endDateParameter);
            }
            sw.Stop();
            _logger?.Log(LogLevel.Message, 
                $"Поток {thread} с {fromDate.ToShortDateString()} по {toDate.ToShortDateString()} время {sw.Elapsed.ToString(@"m\:ss\.ff")}"
             );
        }
    }
